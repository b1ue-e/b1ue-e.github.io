<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>多目标遗传算法NSGA-II实现</title>
    <url>/2024/11/19/NSGA-II/</url>
    <content><![CDATA[<h1 id="NSGA-II"><a href="#NSGA-II" class="headerlink" title="NSGA-II"></a>NSGA-II</h1><h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><p>非支配排序遗传算法（NSGA-II）是一种多目标优化算法，它通过在遗传算法的基础上引入非支配排序和拥挤度计算，以平衡多目标优化问题中的多个目标。NSGA-II是遗传算法的一种改进版本，它在遗传算法的基础上引入了<strong>非支配排序和拥挤度</strong>计算，以平衡多目标优化问题中的多个目标。本文将简要介绍NSGA-II的关键点和实现。<br><span id="more"></span></p>
<h2 id="非支配排序"><a href="#非支配排序" class="headerlink" title="非支配排序"></a>非支配排序</h2><h3 id="支配和非支配关系"><a href="#支配和非支配关系" class="headerlink" title="支配和非支配关系"></a>支配和非支配关系</h3><p>设p和q是两个解，称p支配q，当且仅当，1. 对于所有的子目标，p的目标值都不劣于q的目标值；2. 至少有一个子目标，p的目标值优于q的目标值。</p>
<h3 id="非支配排序-1"><a href="#非支配排序-1" class="headerlink" title="非支配排序"></a>非支配排序</h3><p><em>Non-dominated Sorting</em> 是一种用于多目标优化的排序算法，它将解按照支配关系划分为多个非支配集合。</p>
<ol>
<li>初始化：将所有解放入一个初始非支配集合中。</li>
<li>对每个解计算两个属性：（1）$n_i$:解 $i$ 被其他解支配的次数；（2）$s_i$:解 $i$ 支配的解的集合。</li>
<li>然后找到 $n_i = 0$ 的解，将其放入一个新的集合 $F_1$ 中，此时 $F_1$的等级为1</li>
<li>对 $F_1$ 中的每个解 $i$，将其从 $s_i$ 中删除，然后对 $s_i$ 中的每个解 $j$，计算 $n_j = n_j - 1$，如果 $n_j = 0$，则将其放入 $F_2$ 中，此时 $F_2$ 的等级为2。依此类推，直至所有解被分类。<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fast_non_dominated_sort</span>(<span class="params">population</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    非支配排序</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    fronts = [[]]</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> population:</span><br><span class="line">        <span class="comment"># 计算p的支配关系</span></span><br><span class="line">        p.dominated_solutions = []</span><br><span class="line">        p.domination_count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> q <span class="keyword">in</span> population:</span><br><span class="line">            <span class="keyword">if</span> (p.f1 &lt; q.f1 <span class="keyword">and</span> p.f2 &lt; q.f2) <span class="keyword">or</span> (p.f1 &lt;= q.f1 <span class="keyword">and</span> p.f2 &lt; q.f2) <span class="keyword">or</span> (p.f1 &lt; q.f1 <span class="keyword">and</span> p.f2 &lt;= q.f2):</span><br><span class="line">                p.dominated_solutions.append(q)</span><br><span class="line">            <span class="keyword">elif</span> (q.f1 &lt; p.f1 <span class="keyword">and</span> q.f2 &lt; p.f2) <span class="keyword">or</span> (q.f1 &lt;= p.f1 <span class="keyword">and</span> q.f2 &lt; p.f2) <span class="keyword">or</span> (q.f1 &lt; p.f1 <span class="keyword">and</span> q.f2 &lt;= p.f2):</span><br><span class="line">                p.domination_count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> p.domination_count == <span class="number">0</span>:</span><br><span class="line">            p.rank = <span class="number">1</span></span><br><span class="line">            fronts[<span class="number">0</span>].append(p)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 计算每个解的等级</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(fronts[i]) &gt; <span class="number">0</span>:</span><br><span class="line">        next_front = []</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> fronts[i]:</span><br><span class="line">            <span class="keyword">for</span> q <span class="keyword">in</span> p.dominated_solutions:</span><br><span class="line">                q.domination_count -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> q.domination_count == <span class="number">0</span>:</span><br><span class="line">                    q.rank = i + <span class="number">2</span></span><br><span class="line">                    next_front.append(q)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        fronts.append(next_front)</span><br><span class="line">    fronts.pop()  </span><br><span class="line">    <span class="keyword">return</span> fronts</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="拥挤度计算"><a href="#拥挤度计算" class="headerlink" title="拥挤度计算"></a>拥挤度计算</h2><p><em>Crowding Distance</em> 是一种用于多目标优化的度量方法，它用于评估解在非支配排序中的拥挤程度。</p>
<ul>
<li>拥挤度指目标空间上的每一点与同等级相邻两点之间的局部拥挤距离</li>
<li>使用这一测度可使Pareto解集在目标空间分布比较均匀。<br>具体实现：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_crowding_distance</span>(<span class="params">front</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算拥挤距离</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> front:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    l = <span class="built_in">len</span>(front)</span><br><span class="line">    <span class="keyword">for</span> individual <span class="keyword">in</span> front:</span><br><span class="line">        individual.crowding_distance = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> [<span class="string">&#x27;f1&#x27;</span>, <span class="string">&#x27;f2&#x27;</span>]:</span><br><span class="line">        front.sort(key=<span class="keyword">lambda</span> x: <span class="built_in">getattr</span>(x, m))</span><br><span class="line">        <span class="comment"># 设置边界点的拥挤距离为无穷大</span></span><br><span class="line">        <span class="built_in">setattr</span>(front[<span class="number">0</span>], <span class="string">&#x27;crowding_distance&#x27;</span>, <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>))</span><br><span class="line">        <span class="built_in">setattr</span>(front[-<span class="number">1</span>], <span class="string">&#x27;crowding_distance&#x27;</span>, <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>))</span><br><span class="line">        m_values = [<span class="built_in">getattr</span>(ind, m) <span class="keyword">for</span> ind <span class="keyword">in</span> front]</span><br><span class="line">        min_m = <span class="built_in">min</span>(m_values)</span><br><span class="line">        max_m = <span class="built_in">max</span>(m_values)</span><br><span class="line">        <span class="keyword">if</span> max_m == min_m:</span><br><span class="line">            <span class="keyword">continue</span>  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, l - <span class="number">1</span>):</span><br><span class="line">            distance = (front[i + <span class="number">1</span>].__dict__[m] - front[i - <span class="number">1</span>].__dict__[m]) / (max_m - min_m)</span><br><span class="line">            front[i].crowding_distance += distance</span><br></pre></td></tr></table></figure>
<h2 id="模拟二进制交叉"><a href="#模拟二进制交叉" class="headerlink" title="模拟二进制交叉"></a>模拟二进制交叉</h2><em>Simulated Binary Crossover (SBX)</em> 是一种用于遗传算法中的交叉操作的方法，它模拟了二进制编码中实数的交叉操作。关键是在交叉过程中，根据交叉概率和分布索引来控制交叉的程度。</li>
</ul>
<ol>
<li>首先，从当前解集中选择两个父代个体。</li>
<li>然后，生成两个均匀分布的随机数 $r_1$ 和 $r_2$。通常设置一个交叉概率 $p_c$，如果 $r_1 \leq p_c$，则执行交叉操作，否则直接复制父代个体。</li>
<li>计算交叉参数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">beta = <span class="number">1.0</span> + (<span class="number">2.0</span> * (x_min) / (x_max - x_min))</span><br><span class="line">alpha = <span class="number">2.0</span> - math.<span class="built_in">pow</span>(beta, -(eta + <span class="number">1</span>))</span><br></pre></td></tr></table></figure></li>
<li>计算交叉后的子代个体<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果rand小于等于1/alpha</span></span><br><span class="line">betaq = math.<span class="built_in">pow</span>(rand * alpha, <span class="number">1.0</span> / (eta + <span class="number">1</span>))</span><br><span class="line"><span class="comment"># 否则</span></span><br><span class="line">betaq = math.<span class="built_in">pow</span>(<span class="number">1.0</span> / (<span class="number">2.0</span> - rand * alpha), <span class="number">1.0</span> / (eta + <span class="number">1</span>))</span><br><span class="line">c1 = <span class="number">0.5</span> * ((x_min + x_max) - betaq * (x_max - x_min))</span><br><span class="line">c2 = <span class="number">0.5</span> * ((x_min + x_max) + betaq * (x_max - x_min))</span><br></pre></td></tr></table></figure>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sbx_crossover</span>(<span class="params">parent1, parent2, eta=<span class="number">20</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    模拟二进制交叉</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    child1 = copy.deepcopy(parent1)</span><br><span class="line">    child2 = copy.deepcopy(parent2)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(parent1.chromosome)):</span><br><span class="line">        <span class="keyword">if</span> random.random() &lt;= <span class="number">0.9</span>:</span><br><span class="line">            x1 = parent1.chromosome[i]</span><br><span class="line">            x2 = parent2.chromosome[i]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(x1 - x2) &gt; <span class="number">1e-14</span>:</span><br><span class="line">                x_min = <span class="built_in">min</span>(x1, x2)</span><br><span class="line">                x_max = <span class="built_in">max</span>(x1, x2)</span><br><span class="line">                rand = random.random()</span><br><span class="line">                beta = <span class="number">1.0</span> + (<span class="number">2.0</span> * (x_min) / (x_max - x_min))</span><br><span class="line">                alpha = <span class="number">2.0</span> - math.<span class="built_in">pow</span>(beta, -(eta + <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">if</span> rand &lt;= <span class="number">1.0</span> / alpha:</span><br><span class="line">                    betaq = math.<span class="built_in">pow</span>(rand * alpha, <span class="number">1.0</span> / (eta + <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    betaq = math.<span class="built_in">pow</span>(<span class="number">1.0</span> / (<span class="number">2.0</span> - rand * alpha), <span class="number">1.0</span> / (eta + <span class="number">1</span>))</span><br><span class="line">                c1 = <span class="number">0.5</span> * ((x_min + x_max) - betaq * (x_max - x_min))</span><br><span class="line">                beta = <span class="number">1.0</span> + (<span class="number">2.0</span> * (<span class="number">1.0</span> - x_max) / (x_max - x_min))</span><br><span class="line">                alpha = <span class="number">2.0</span> - math.<span class="built_in">pow</span>(beta, -(eta + <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">if</span> rand &lt;= <span class="number">1.0</span> / alpha:</span><br><span class="line">                    betaq = math.<span class="built_in">pow</span>(rand * alpha, <span class="number">1.0</span> / (eta + <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    betaq = math.<span class="built_in">pow</span>(<span class="number">1.0</span> / (<span class="number">2.0</span> - rand * alpha), <span class="number">1.0</span> / (eta + <span class="number">1</span>))</span><br><span class="line">                c2 = <span class="number">0.5</span> * ((x_min + x_max) + betaq * (x_max - x_min))</span><br><span class="line">                c1 = <span class="built_in">min</span>(<span class="built_in">max</span>(c1, <span class="number">0.0</span>), <span class="number">1.0</span>)</span><br><span class="line">                c2 = <span class="built_in">min</span>(<span class="built_in">max</span>(c2, <span class="number">0.0</span>), <span class="number">1.0</span>)</span><br><span class="line">                child1.chromosome[i] = c1</span><br><span class="line">                child2.chromosome[i] = c2</span><br><span class="line">    <span class="keyword">return</span> child1, child2</span><br></pre></td></tr></table></figure>
<h2 id="多项式变异"><a href="#多项式变异" class="headerlink" title="多项式变异"></a>多项式变异</h2><em>Polynomial Mutation (PM)</em> 是一种用于遗传算法中的变异操作的方法，它模拟了二进制编码中实数的变异操作。<img src="/2024/11/19/NSGA-II/PM.png" class="" title="PM">
</li>
</ol>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">polynomial_mutation</span>(<span class="params">individual, eta=<span class="number">20</span>, mutation_prob=<span class="number">1.0</span>/<span class="number">30</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    多项式变异</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(individual.chromosome)):</span><br><span class="line">        <span class="keyword">if</span> random.random() &lt;= mutation_prob:</span><br><span class="line">            x = individual.chromosome[i]</span><br><span class="line">            delta1 = (x - <span class="number">0.0</span>) / (<span class="number">1.0</span> - <span class="number">0.0</span>)</span><br><span class="line">            delta2 = (<span class="number">1.0</span> - x) / (<span class="number">1.0</span> - <span class="number">0.0</span>)</span><br><span class="line">            rand = random.random()</span><br><span class="line">            mut_pow = <span class="number">1.0</span> / (eta + <span class="number">1.</span>)</span><br><span class="line">            <span class="keyword">if</span> rand &lt; <span class="number">0.5</span>:</span><br><span class="line">                xy = <span class="number">1.0</span> - delta1</span><br><span class="line">                val = <span class="number">2.0</span> * rand + (<span class="number">1.0</span> - <span class="number">2.0</span> * rand) * math.<span class="built_in">pow</span>(xy, (eta +<span class="number">1</span>))</span><br><span class="line">                deltaq = math.<span class="built_in">pow</span>(val, mut_pow) -<span class="number">1.0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                xy = <span class="number">1.0</span> - delta2</span><br><span class="line">                val = <span class="number">2.0</span> * (<span class="number">1.0</span> - rand) + <span class="number">2.0</span> * (rand -<span class="number">0.5</span>) * math.<span class="built_in">pow</span>(xy, (eta +<span class="number">1</span>))</span><br><span class="line">                deltaq = <span class="number">1.0</span> - math.<span class="built_in">pow</span>(val, mut_pow)</span><br><span class="line">            x = x + deltaq</span><br><span class="line">            x = <span class="built_in">min</span>(<span class="built_in">max</span>(x, <span class="number">0.0</span>), <span class="number">1.0</span>)</span><br><span class="line">            individual.chromosome[i] = x</span><br><span class="line">    <span class="keyword">return</span> individual</span><br></pre></td></tr></table></figure>
<h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><p>[1] Deb, K., Pratap, A., Agarwal, S., &amp; Meyarivan, T. A. M. T. (2002). A fast and elitist multiobjective genetic algorithm: NSGA-II. IEEE transactions on evolutionary computation, 6(2), 182-197. </p>
<p>[2] <a href="https://blog.csdn.net/qq_46450354/article/details/127890916">[遗传算法]模拟二进制交叉SBX与多项式变异</a>  </p>
<p>[3] <a href="https://github.com/bujibujibiuwang/NSGA-II-in-python">NSGA-II-in-python</a></p>
]]></content>
      <categories>
        <category>Gentic Algorithm</category>
      </categories>
      <tags>
        <tag>GA</tag>
        <tag>multi-objective</tag>
      </tags>
  </entry>
  <entry>
    <title>kmacoder44. 开发商购买土地</title>
    <url>/2024/12/05/kamacoder44/</url>
    <content><![CDATA[<h1 id="开发商购买土地"><a href="#开发商购买土地" class="headerlink" title="开发商购买土地"></a>开发商购买土地</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个城市区域内，被划分成了n * m个连续的区块，每个区块都拥有不同的权值，代表着其土地价值。目前，有两家开发公司，A 公司和 B 公司，希望购买这个城市区域的土地。 </p>
<p>现在，需要将这个城市区域的所有区块分配给 A 公司和 B 公司。</p>
<p>然而，由于城市规划的限制，只允许将区域按<strong>横向或纵向</strong>划分成两个子区域，而且每个子区域都必须包含一个或多个区块。 为了确保公平竞争，你需要找到一种分配方式，使得 A 公司和 B 公司各自的子区域内的土地总价值之差最小。 </p>
<p>注意：区块不可再分。</p>
<p><strong>输入描述</strong></p>
<blockquote>
<p>第一行输入两个正整数，代表 n 和 m。<br>接下来的 n 行，每行输出 m 个正整数。</p>
</blockquote>
<p><strong>输出描述</strong>  </p>
<blockquote>
<p>输出一个整数，代表 A 公司和 B 公司各自的子区域内的土地总价值之差的最小值。</p>
</blockquote>
<p><strong>输入示例</strong></p>
<blockquote>
<p>3 3<br>1 2 3<br>2 1 3<br>1 2 3</p>
</blockquote>
<p><strong>输出示例</strong></p>
<blockquote>
<p>0</p>
</blockquote>
<p><strong>提示信息</strong></p>
<blockquote>
<p>如果将区域按照如下方式划分：<br>1 2 | 3<br>2 1 | 3<br>1 2 | 3<br>两个子区域内土地总价值之间的最小差距可以达到 0。</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>以行为例，可以将每一行的前缀和求出来，然后遍历每一行，将每一行的前缀和分为两部分，一部分为前i个元素的和，另一部分为后n-i个元素的和，然后取两者的差的绝对值，取最小值即可。<br>前缀和可以将复杂度从$O(n^3)$降到$O(n^2)$。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n&#123;&#125;,m&#123;&#125;;</span><br><span class="line">    cin &gt;&gt; n&gt;&gt;m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">s</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m));</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            cin &gt;&gt; s[i][j];</span><br><span class="line">            sum += s[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 横向情况</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">row</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            row[i] += s[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 纵向情况</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">col</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            col[i] += s[j][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = INT32_MAX;</span><br><span class="line">    <span class="type">int</span> sub_row = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">      sub_row += row[i];</span><br><span class="line">      res = <span class="built_in">min</span>(res,<span class="built_in">abs</span>(sum<span class="number">-2</span>*sub_row));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sub_col = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt;m;i++)&#123;</span><br><span class="line">      sub_col += col[i];</span><br><span class="line">      res = <span class="built_in">min</span>(res,<span class="built_in">abs</span>(sum<span class="number">-2</span>*sub_col));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://programmercarl.com/kamacoder/0044.%E5%BC%80%E5%8F%91%E5%95%86%E8%B4%AD%E4%B9%B0%E5%9C%9F%E5%9C%B0.html#%E6%80%9D%E8%B7%AF">programmercarl</a></p>
<!-- flag of hidden posts -->]]></content>
      <categories>
        <category>kamacoder</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>Predicting Long-term Dynamics of Complex Networks via Identifying Skeleton in Hyperbolic Space</title>
    <url>/2024/11/13/DiskNet/</url>
    <content><![CDATA[<h1 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h1><p>学习复杂的网络动力学是理解、模拟和控制现实世界复杂系统的基础。尽管人们在预测网络节点的未来状态方面做出了巨大努力，但捕捉长期动态的能力在很大程度上仍然有限。这是因为他们忽略了一个事实，即复杂网络的长期动态主要受其固有的低维流形（即骨架）支配。因此，我们提出了动态不变骨架神经网络（DiskNet），它基于双曲空间的重整化群结构来识别复杂网络的骨架，从而同时保留拓扑和动力学特性。具体来说，我们首先通过物理信息双曲嵌入将具有各种动力学特性的复杂网络浓缩为简单骨架。然后，我们设计图神经常微分方程来捕捉骨架上的浓缩动力学。最后，我们使用基于度的超分辨率模块将骨架网络和动力学恢复为原始网络和动力学。通过对三个代表性动态以及五个真实世界和两个合成网络的广泛实验，证明了所提出的 DiskNet 的卓越性能，就长期预测准确率而言，它比最先进的基线平均高出 10.18%。转载代码请访问：<a href="https://github.com/tsinghua-fib-lab/DiskNet">https://github.com/tsinghua-fib-lab/DiskNet</a></p>
<span id="more"></span>
<h1 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1 INTRODUCTION"></a>1 INTRODUCTION</h1><p>现实世界中许多复杂系统的演化行为，如大脑[9]、社会网络[51]和生态系统[15]，都可以建模为复杂网络的动力学[4]，其中系统内的组件被视为网络中的节点，组件之间的耦合相互作用被视为边[13]。学习这些复杂网络的动力学有助于提高分析这些网络的能力，从而促进众多重要应用，包括了解其内在弹性[13]、预测其未来状态[31, 35]和控制其状态[28]等。然而，复杂网络中通常存在大量节点和边。一方面，大规模网络大大增加了复杂网络推理和估计任务的计算复杂度。另一方面，大量不太重要的节点作为干扰变量，有可能阻碍我们揭示网络的有效动态[13]。在这种情况下，一个基本问题出现了：给定一个任意的复杂网络，我们能否找到一个低维骨架，在此骨架上对粗尺度的长期动态进行建模，从而获得较高的预测性能和较低的计算成本？</p>
<p>作为一个长期存在的问题，人们开发了许多方法来降低大规模网络的维度，包括统计物理方法[41]和机器学习方法[20, 22]。其中，统计物理方法利用重整化群技术[14, 40]来识别保留度分布和聚类系数的骨架。机器学习方法 [20, 22] 学习图粗化策略，以保持原始网络与使用粗化网络重建的网络之间的拓扑和节点特征一致性。所有这些方法都只保留了静态拓扑和节点信息，忽略了网络的动态变化 [14、20、22、40]。因此，它们无法捕捉节点动态的集体行为，无法准确预测其长期演变。此外，有几种分析方法表明，复杂网络动态的关键属性，如弹性 [13] 或临界时间延迟 [29]，可以嵌入到一个超低维度的子曲面中 [13, 29]。然而，这些方法依赖于过于简化的网络拓扑假设，如均质节点度或基于度的均场[29, 39]，无法得到理想维度的骨架。综上所述，复杂的网络及其错综复杂的动态能否浓缩成低维骨架仍是一个悬而未决的问题。</p>
<p>然而，开发一种有效的方法来学习骨架和骨架网络上的相应动力学也是一项艰巨的任务，其中存在以下挑战。首先，确定有利于最准确预测复杂网络演化行为的骨架具有挑战性。骨架可以通过将节点集群粗分为超级节点来获得。然而，我们对如何在保留骨架网络内在动态的同时找到这样的簇缺乏足够的了解。其次，如何在骨架网络中的节点状态与原始网络之间建立可逆映射是第二个挑战。这涉及建立一个聚合函数，根据子节点计算超级节点的状态，以及一个提升函数，将每个超级节点的状态映射回子节点。由于聚合过程不可避免地会带来信息损失，因此如何建立一个高效的提升函数是一个关键问题</p>
<p>在本文中，我们提出了一种名为 “动态不变骨架神经网络（DiskNet）”的新型深度学习框架，用于识别双曲空间中复杂网络的低维骨架，为其长期动态建模。该框架通过物理信息嵌入来识别骨架。这些嵌入基于在双曲空间中开发的重整化群技术进行初始化，然后在端到端训练过程中进行微调，使知识与数据相结合，从而克服第一个挑战。然后，DiskNet 利用图神经常微分方程对骨架网络上的凝聚动力学进行有效建模。最后，它利用精心设计的基于度的超分辨率模块作为提升函数，将凝聚动态映射回原始网络。该模块利用节点在度数上的同质性来识别共享相同提升网络的节点群，从而构建有效的提升函数来解决第二个挑战。</p>
<h2 id="contribution"><a href="#contribution" class="headerlink" title="contribution"></a>contribution</h2><ul>
<li><p>我们建议根据重整化群理论中物理知识启发下的双曲嵌入来识别骨架，从而使我们能够结合知识和数据来学习有效的骨架。</p>
</li>
<li><p>我们开发了一个功能强大的图神经常微分方程（ODEs），并集成了一个新颖的超分辨率模块，利用度数接近的节点的同质性，使我们能够精确地模拟骨架上的凝聚动力学，并将其映射到原始网络中。</p>
</li>
<li><p>在五个真实网络拓扑和两个合成网络拓扑的三个代表性网络动态上进行的大量实验结果表明，DiskNet 的预测准确率平均比最先进的基线高出 10.18%，这表明了它的优越性。</p>
</li>
</ul>
<h1 id="2-PROBLEM-FORMULATION"><a href="#2-PROBLEM-FORMULATION" class="headerlink" title="2 PROBLEM FORMULATION"></a>2 PROBLEM FORMULATION</h1><p>在不失一般性的前提下，网络拓扑由邻接矩阵 $A \in {0, 1}^{N \times N}$ 表示，其中每个元素 $a_{ij}= 1$  表示节点 i 和 j 之间的连接。网络动力学描述了图 G 上节点状态的演化，其中考虑了每个节点的自动力学以及与其邻居的交互作用，其方程为</p>
<script type="math/tex; mode=display">\frac{dx_i}{dt} = f(x_i) + \sum^{N}_{j \neq i}{a_{ij}g(x_i,x_j)}</script><p>其中，f 表示自动力学，g 表示节点间的耦合动力学。节点状态矩阵表示为 $\textbf{X} \in \mathbb{R}^{N \times L \times d}$ ，代表在连续的 L 个时间步序列中 N 个节点的 d 维状态的观测值。</p>
<p>此外，我们认为图 G 的骨架为 $G<em>s = (\mathcal{V}_s, A_s)$，其中 $A_s \in {0, 1}^{\gamma N \times \gamma N}$ 描述了集合 $\mathbb{V}_s$ 中超级节点（定义为原始节点的聚合）之间的连接。这里，γ 表示骨架相对于原始拓扑的缩减率、given by $γ = \frac{V_s}{V}$ .超级节点与原始节点之间的对应关系由赋值矩阵 $P \in {0, 1}^{\gamma N \times N}$ 定义，其中 $p</em>{ij} = 1$ 表示节点 j 被聚合为超级节点 i。函数 $x<em>{s,i}=u(x</em>{P<em>i})$  描述了超级节点 i 的状态如何从其子节点汇总而来。骨架上网络的动态定义与公式 1 相同，表示为 $\frac{dx</em>{s,i}}{dt}$。超级节点的状态通过提升函数 v 映射回其子节点，即 $x<em>i = v(x</em>{s,i})$ 。我们强调，通过聚合而非剪枝获得网络骨架的目的是将相似节点的集体动态整合为一个具有代表性的超级节点。</p>
<p>我们的目标是确定赋值矩阵 P、状态聚合函数 u 和提升函数 v，从而建立图 G 的低维骨架 $G<em>s$ 。随后，通过在骨架上建立动态模型 $\frac{dx</em>{s,i}}{dt}$ 并将其映射回子节点，我们的目标是在给定历史观测值 $X<em>{lookback}$ 的情况下，实现对节点状态长期演化 $X</em>{horizon}$ 的准确预测。整个过程如图 1 所示</p>
<h1 id="3-METHOD"><a href="#3-METHOD" class="headerlink" title="3 METHOD"></a>3 METHOD</h1><p><code>在本节中，我们将提出动态不变骨架神经网络（DiskNet），通过识别双曲空间中的骨架来预测复杂网络的长期动态。整体框架如图 2 所示。根据上述挑战，我们首先提出了双曲重整化群（RG）模块，利用双曲几何的强大表示能力捕捉节点的拓扑和动态相似性，并自适应计算赋值矩阵，指导节点赋值和动态聚合。然后，设计了一个神经 ODE 模型来模拟骨架上超级节点的神经动力学，其中包含两种机制：自我动力学和邻居相互作用。最后，提出了一个基于度聚类的超分辨率模块，将骨架上的动态表示提升到原始节点上。</code></p>
<h2 id="3-1-Hyperbolic-Renormalization-Group"><a href="#3-1-Hyperbolic-Renormalization-Group" class="headerlink" title="3.1 Hyperbolic Renormalization Group"></a>3.1 Hyperbolic Renormalization Group</h2><p>给定复杂网络的邻接矩阵 A，识别网络骨架 $A_s$ 的关键在于根据网络的拓扑特性和节点动态的潜在相似性确定赋值矩阵 P。我们在双曲空间 [26] 中测量原始节点和超级节点之间的相似性。在此基础上，我们推导出一个自适应分配矩阵，为每个超级节点聚合子节点的动态表示，该矩阵共同包含拓扑和动态特征。我们通过初始化超级节点的双曲嵌入来引入先验物理知识，从而指导模型训练。</p>
<p><em>3.1.1 learnable hyperbolic embedding</em> 庞加莱盘是一种二维双曲几何，负曲率特性使节点嵌入之间的双曲距离与它们在图中的距离相一致。相同维度的双曲空间比欧几里得空间容量更大，因此更适合表示大规模网络中节点的拓扑和动态信息。庞加莱盘上两点之间的距离为</p>
<script type="math/tex; mode=display">d^c_H(x,y)=\frac{1}{\sqrt{|c|}}\mathrm{arcosh}(1-\frac{2c||x-y||^2}{(1+c||x||^2)(1+c||y||^2)})</script><p>以前的工作主要是学习网络拓扑的双曲嵌入 $C^H \in R^{N \times 2}$ ，初始化后将其冻结在 DiskNet 中，用于对原始拓扑进行分层表示。我们的核心理念是为每个超级节点维护一个可学习的双曲嵌入 $C^H_s \in R^{\gamma N \times 2}$ ， 以捕捉其所有子节点的动态特征.我们首先根据第 4.3.4 节所述方法初始化 $C_s^H$ ，引入先验物理知识，然后在端到端训练过程中对其进行微调。考虑到在欧几里得空间定义的计算规则不适用于双曲空间的矢量，我们使用对数映射将 $C^H$ 和 $C^H_s$ 投影到相应的欧几里得坐标上。</p>
<script type="math/tex; mode=display">\theta^E_z=\frac{2}{\sqrt{|c|}\lambda^c_z}\mathrm{arctanh}(\sqrt{|c|} ||-z \oplus_c \theta^H||)\frac{-z \oplus_c \theta^H}{||-z \oplus_c \theta^H||}</script><p>其中，$\oplus_c$ 表示莫比乌斯加法 [30]， $\lambda^c_x=\frac{2}{1+c||x||^2}$ 。  $\theta^H$ and $\theta^E$ 分别表示双曲空间和欧几里得空间中的向量。与大多数研究[26, 32, 34, 42]一致，双曲流形的切线空间选在原点 $\mathbb{O}$，曲率设为-1。我们将在第 4.3.2 节中详细验证双曲嵌入在表示节点拓扑和动态相似性方面的优越性。</p>
<p><em>3.1.2 Adaptive assignment matrix.</em> 根据原始节点和超级节点的双曲嵌入，我们计算出自适应赋值矩阵为</p>
<script type="math/tex; mode=display">P = {\rm softmax}(\tilde{C}_s\tilde{C}^T)</script><p>其中，softmax 按行计算，$\tilde{C} = MLP(C^E)$ 和 $\tilde{C}<em>s = MLP(C^E_s)$。我们最小化$L_E=\frac{1}{N}\sum^N</em>{i=1}{H(P_i)}$，其中 H 表示熵函数，$P_i$ 是 P 的第 i 列，以限制赋值矩阵的每一列都接近单热向量。此外，我们最小化 $L_R=||A,P^TP||_F$ 来启发式地引导赋值矩阵保持原始拓扑的骨架，其中 $||\cdot||_F$ 表示弗罗贝尼斯规范。</p>
<p><em>3.1.3 Node dynamics aggregation.</em> 我们采用图卷积神经网络来捕捉原始节点的动态传播，并将其聚合为超级节点的动态表示，即</p>
<script type="math/tex; mode=display">H = \sigma((\tilde{D}^{-\frac{1}{2}} \tilde{A} \tilde{D}^{-\frac{1}{2}} X) \Theta_1) \in \mathbb{R}^{N \times d},</script><script type="math/tex; mode=display">X_s = PH \in \mathbb{R}^{\gamma N \times d}</script><p>其中，$\tilde{D} = \sum<em>{j}{\tilde{A}</em>{ij}}$，$\tilde{A} = A + I$,$\Theta$ 为可学习参数。超级节点之间的连接由邻接矩阵 $A<em>s = PAP^T$ 描述，其中元素 $a</em>{s,ij}$ 表示超级节点内部（i = j）或不同超级节点之间（i≠ j）的子节点连接总数。</p>
<p><em>3.1.4 Physics-informed initialization.</em> 统计物理学将节点相似度的意义赋予节点嵌入波恩卡莱盘的角坐标，并采用基于角坐标的重整化群[14]。这种设计有助于保留骨架中网络拓扑的度分布和聚类系数。虽然这种方法不能保证有效地表示网络动态，但 DiskNet 可以在随后的端到端训练中自动调整超节点的可学习双曲嵌入。因此，我们根据角坐标对原始节点进行排序，并将其划分为  $\frac{1}{\gamma}$ 个节点的节点组，以预先定义赋值矩阵 $P<em>0$ ，用于预训练自适应赋值模块，其损失函数为 $L_p = \frac{1}{\gamma N^2}\sum{|P-P_0|}$。我们在附录 C 中提供了预训练阶段的伪代码。超级节点的双曲嵌入初始值设为 $c^H</em>{s,i} = \frac{1}{|P<em>{0,i}|}\sum</em>{j \in P<em>{0,i}}{c^H_j}$，其中 $P</em>{0,i}$ 表示属于超级节点 i 的子节点集。</p>
<h2 id="3-2-Neural-Dynamics-on-Skeleton"><a href="#3-2-Neural-Dynamics-on-Skeleton" class="headerlink" title="3.2 Neural Dynamics on Skeleton"></a>3.2 Neural Dynamics on Skeleton</h2><p>在获得网络动力学骨架和超级节点的聚合状态后，我们将网络动力学形式保持为公式 1，并使用神经 ODE 对其进行建模</p>
<p><em>3.2.1 ODE function</em></p>
<p>现在我们定义骨架潜在动力学 $\frac{dZ<em>s}{dt}$ 的前向 ODE 函数。考虑到每个超级节点 $x</em>{s,i}$ 的演化受其自身动力学和耦合动力学的影响，参数化的时间导数由两部分组成：一部分是自动力学函数 $f(Z_s)$ ，另一部分代表与邻近节点的相互作用 $g(Z_s, A_s)$。因此，每个超级节点的动态方程为</p>
<script type="math/tex; mode=display">\frac{dZ_s}{dt} = f(Z_s) + g(Z_s, A_s)</script><p>其中，f 是 MLP，g 是负责信息传播的 GNN</p>
<script type="math/tex; mode=display">g(Z_s, A_s) = \sigma(A\sigma(Z_s\Theta_3)\Theta_2) .</script><p><em>3.2.2 Solve</em> 给定 ODE 函数后，骨架动力学的预测轨迹可由任何 ODE 求解器作为初值问题求解</p>
<script type="math/tex; mode=display">Z_{s,T} = Z_{s,0} + \int^T_0{f(Z_{s,t}) + g(Z_{s,t}, A_s) dt}</script><p>其中，初始状态 $Z_{s,0} = MLP(X_s) \in \mathbb{R}^{\gamma N \times 1}$。这样，我们就可以预测超级节点在任意连续时间点 T 的状态。</p>
<h2 id="3-3-Lift-to-Original-Nodes"><a href="#3-3-Lift-to-Original-Nodes" class="headerlink" title="3.3 Lift to Original Nodes"></a>3.3 Lift to Original Nodes</h2><p>在获得骨架上超级节点的预测轨迹后，需要将其提升回原图中的每个独立节点，以完成网络动态预测。然而，在超级节点的聚合过程中，不可避免地会出现信息丢失，例如同一超级节点内子节点状态的异质性。简单地将超级节点的预测值复制到其子节点上并不足以实现准确的扩展。为了克服这一难题，受统计物理学研究的启发 [13, 29]，我们设计了一个基于度聚类的超级分辨率模块。</p>
<p><em>3.3.1 Degree-based clustering.</em> 通过采用程度加权平均场方法，可以将程度相似节点的状态和临界点压缩到一个超级节点中进行预测 [13, 27, 29] 。这意味着节点的集体动态表现出了与节点度数有关的同质性。受此启发，考虑到现实世界的网络通常遵循幂律分布，我们选择使用度数对数作为特征，通过 K-means 算法对节点进行聚类，并在每个聚类中执行超分辨率。事实上，在 Poincaré 磁盘中，节点的度数直接对应于其径向坐标。因此，具有相似径向坐标的节点应被识别为属于同一个超级节点。</p>
<p><em>3.3.2 Super-resolution.</em> 基于骨架动态的有效表示，超分辨率模块的设计不需要太复杂。我们用 $N<em>c$ 表示第 c 个集群中的节点集，用 Xc 表示它们的历史观测值，用 $Z</em>{c,T}$ 表示相应超级节点的预测值。由于扩展操作只是简单地将超级节点的预测值复制到其子节点，而不进行区分，因此 Zc,T 是对每个节点的粗略和同质预测。我们根据历史观测值 $X<em>c$ 对 $Z</em>{c,T}$ 进行细化，得到精确预测值为</p>
<script type="math/tex; mode=display">X_{c,T} = \sigma((h_0 || h_1)\Theta_4)</script><p>其中 || 表示连接操作， $h<em>0 = MLP(X_c)$ and $h_1 = MLP(Z</em>{c,T})$ 。这样，我们就完成了网络动态预测。我们将在第 4.4.2 节中证明，随着集群数 k 的增加，预测精度将迅速达到上限。因此，有限的 k 设置足以实现良好的预测性能。</p>
<h2 id="3-4-Training"><a href="#3-4-Training" class="headerlink" title="3.4 Training"></a>3.4 Training</h2><p>现在我们介绍 DiskNet 的训练过程。在开始端到端训练之前，我们首先初始化原始节点和超级节点的双曲嵌入（如第 4.3.4 节所述），并利用先前的物理知识预训练自适应赋值模块。随后，在每次迭代中，模型都会在损失函数 LE 和 LR 的指导下学习自适应分配矩阵。骨架动态预测使用 L2 误差进行更新，即 $L<em>s = MSE(\overline{Z}</em>{s,T}, Z<em>{s,T})$ ，其中 $\overline{Z}</em>{s,T}$ 代表超级节点的预测状态，$Z_{s,T}$ 是根据赋值矩阵和状态编码器获得的基本真实值。最后，利用所有原始节点预测的 L2 误差 $L_p = MSE(\overline{X}_T, X_T)$ 更新超分辨率模块。由于 Poincaré 盘是欧几里得空间的保角映射，因此在用梯度更新节点嵌入时，必须根据黎曼度量张量来缩放梯度。</p>
<script type="math/tex; mode=display">\nabla_H(\theta) = (\frac{1-||\theta||}{2})^2 \nabla_E(\theta)</script><p>其中，$\nabla_E(\theta)$ 和 $\nabla_H(\theta)$ 分别是向量 θ 的欧氏梯度和双曲梯度。完成端到端训练后，我们分别对超分辨率模块进行微调，以提高预测性能。</p>
<img src="/2024/11/13/DiskNet/model.png" class="" title="model">
<h1 id="4-EXPERIMENTS"><a href="#4-EXPERIMENTS" class="headerlink" title="4 EXPERIMENTS"></a>4 EXPERIMENTS</h1><p>在本节中，我们将介绍 DiskNet 的评估结果。我们首先介绍了用于测试的动态和网络拓扑结构，然后介绍了用于比较的基线。然后，我们分析了长期预测性能、识别骨架的可解释性以及敏感性分析。附录 B 提供了所有实验的软件和硬件环境的详细信息。</p>
<h2 id="4-1-Experiment-Setup"><a href="#4-1-Experiment-Setup" class="headerlink" title="4.1 Experiment Setup"></a>4.1 Experiment Setup</h2><p>我们对三个具有代表性的非线性动态系统进行了实验，在五个真实世界的网络拓扑结构和两个合成拓扑结构上运行。有关数据集生成的详细信息，请参见附录 A.2。</p>
<p>4.1.1 Network Topology.  我们考虑了基础设施、社交网络、大脑网络和万维网 1 中的五个真实世界网络拓扑结构[36]：(a) 美国的电网（PowerGrid）；(b) 果蝇的大脑网络；(c) 互赞的 Facebook 页面（Social）；(d) 链接到 www.epa.gov 的页面（Web）；(e) 两个非美国机场之间的联系（Airport）。此外，我们还考虑了两个合成网络：(f) Barabási-Albert 网络 (BA) [3]；(g) Watts-Strogatz 网络 (WS) [43]。所有拓扑结构的统计特征如表 1 所示。</p>
<p>4.1.2 Network Dynamics. 我们考虑了生物学和物理学中三种有代表性的动力学：(a) Hindmarsh-Rose 动力学[6]，(b) FitzHugh-Nagumo 动力学[12]，(c) Coupled Rössler 动力学[1]。相关方程和参数设置详见附录 A.1</p>
<h2 id="4-2-Baseline"><a href="#4-2-Baseline" class="headerlink" title="4.2 Baseline"></a>4.2 Baseline</h2><p>在所有数据集上，我们与以下基于 GNN 的最先进方法进行了比较</p>
<ul>
<li><p>DCRNN [24] 采用双向随机行走和编码器-解码器架构，通过计划采样实现准确的时空预测。</p>
</li>
<li><p>GraphWaveNet [44] 采用自适应依赖矩阵，通过节点嵌入捕捉隐藏的空间依赖关系。</p>
</li>
<li><p>AGCRN [2]：引入了两个自适应模块和递归网络，可自动捕捉交通序列中细粒度的空间和时间相关性。</p>
</li>
<li><p>NDCN [50] 通过结合神经 ODE 和 GNN，捕捉复杂网络上的连续时间动态。</p>
</li>
<li><p>STGNCDE [10] 将时空图神经网络与神经控制微分方程相结合，用于预测多变量时间序列。</p>
</li>
<li><p>MTGODE [19] 将多变量时间序列抽象为具有随时间变化的节点特征的动态图，并对其在潜空间中的连续动态进行建模。</p>
</li>
<li><p>FourierGNN [48] 是最先进的多变量时间序列预测 GNN 模型。它引入了超变量图，并在傅立叶空间中执行矩阵乘法。</p>
</li>
</ul>
<h2 id="4-3-Performance-Evaluation"><a href="#4-3-Performance-Evaluation" class="headerlink" title="4.3 Performance Evaluation"></a>4.3 Performance Evaluation</h2><p>在本节中，我们将分析 DiskNet 的长期预测性能、识别骨架和计算成本。</p>
<p>4.3.1 Long-term Prediction. 我们根据平均绝对误差 (MAE) 评估了 DiskNet 对所有拓扑结构和动态的长期预测性能。我们为模型提供了过去 12 个时间步的观测轨迹，并要求其预测未来 120 个时间步的节点状态。在所有实验中，DiskNet 的缩减率 γ 和集群数 k 分别设置为 50%和 10，设置的原因将在第 4.4 节中解释。</p>
<p>120 个时间步的平均性能如表 1 所示。值得注意的是，在几乎所有情况下，DiskNet 的长期预测性能都远远优于所有基线，在某些情况下提高幅度超过 50%。此外，我们还可以观察到，即使是最先进的模型，次优模型在不同场景下也会有所不同，这表明它们的性能存在波动。这一方面表明，我们的方法能够在各种情况下准确识别网络动力学骨架并建立模型。另一方面，它也强调了低维骨架对于稳定、准确的长期预测的重要性。相比之下，同样采用图神经 ODE 的 NCDN 和 MTGODE 模型只在少数情况下表现良好，这可能是因为它们对整个网络进行建模时，没有有效地聚合节点的关键集体行为。</p>
<p>4.3.2 Dynamics Skeleton. 然后，我们通过对比实验和可视化分析来研究 DiskNet 所识别的动态骨架。我们比较了启发式、图池和重整化组等五种基线方法：(a) 随机分配；(b) 基于节点度的阈值分配；(c) 基于中心度的阈值分配；(d) DiffPool [49]；(e) GMPool [21]；(f) 静态 RG [14]。前三种方法都是根据一定的规则选择超级节点，然后将子节点随机分配给超级节点。两种图池方法的赋值规则与原论文一致。RG 方法仅根据节点的拓扑特征分配节点，因此被称为静态 RG。在所有实验中，为确保公平性，在使用基线获得分配矩阵后，使用 DiskNet 对状态聚合和骨架动力学等模块进行端到端训练。所有模型的缩减率 γ 设为 50%。</p>
<p>如表 2 所示，我们在所有拓扑结构中对 Hindmarsh-Rose 动力学进行了实验。凭借双曲空间强大的表示能力，DiskNet 确定的骨架捕捉到了节点的长期动态变化，从而在所有场景下都能获得比基线更准确的预测结果。启发式方法只考虑拓扑特征而忽略了节点动态，在某些情况下表现不如随机分配法。此外，用欧几里得空间表示节点动态以推导赋值矩阵的图集合方法无法像双曲空间那样有效地测量节点相似性和捕捉潜在的动态交互。在节点分类任务中也有类似的观察结果 [32，33]。虽然静态 RG 方法也利用双曲几何来表示节点特征，但它在计算赋值矩阵时只考虑了静态拓扑特征，而忽略了节点动态的相似性。因此，它无法识别长期动态的骨架.</p>
<p>我们在图 4 中展示了静态 RG 方法和 DiskNet 在相同拓扑但不同动态条件下识别出的骨架，其中动态曲线代表所有节点的平均轨迹。我们使用了缩减率 γ = 0.02% 的 500 节点 BA 网络的结果，以避免因网络规模过大而造成视觉混乱（表 1 中真实世界网络的可视化骨架见附录 D.1）。由于静态 RG 方法不考虑动态性，因此如图 4(a) 所示，三种动态下识别出的骨架是相同的。相比之下，DiskNet 在不同动力学条件下识别出的骨架存在差异。对于 FitzHugh-Nagumo 动力学（图 4(c)）和耦合罗斯勒动力学（图 4(d)），所有节点都表现出振荡行为，DiskNet 识别出的超级节点数量相似，分配模式也相似。然而，对于节点动态各异但趋势简单的 Hindmarsh-Rose 动力学，相应的骨架往往能捕捉到较少的超级节点。</p>
<p>对 DiskNet 所识别骨架的进一步分析表明，大多数超级节点与其子节点共享相同的局部邻域，但也存在子节点位置偏离的情况，尤其是在 Hindmarsh-Rose 动力学中（图 4(b)）。现有研究[14]已经证明，如果只考虑拓扑特征，在庞加莱圆盘上具有相似角度的节点应该属于同一个超级节点，而 DiskNet 则表明，如果考虑节点的动态特性，这一结论就不再成立。由于具有相似的动态特性，即使角度坐标有本质区别的节点也可能被分配到同一个超级节点中。此外，我们还观察到，具有相同角度坐标的节点可能会因为径向坐标的不同而被分配到不同的超级节点，这归因于节点度数与其动态之间的相关性[29]。最后，值得注意的是，有些超级节点只分配了少量的子节点，这将在第 4.4.1 节中进一步解释。</p>
<p>4.3.3 Computational Cost. 在推理过程中，DiskNet 只需要对骨架上的前向 ODE 函数进行积分，与之前基于神经 ODE 的方法相比，大大节省了计算资源。我们比较了在不同拓扑结构上使用不同缩减率 γ 的 DiskNet 和其他两种基于神经 ODE 的基线方法，以衡量单样本推理的时间成本。图 5 中的结果表明，即使有超分辨率模块带来的额外计算开销，γ = 50% 的 DiskNet 也能达到与 NDCN 相当的性能。事实上，随着网络规模的增大，网络动力学的降维潜力往往超过 50%（我们将在第 4.4.1 节中验证这一点）。因此，在预测大规模网络动态方面，DiskNet 比以往基于神经 ODE 的方法具有更高的实用价值。</p>
<p>4.3.4 Physics-informed Initialization. 表 1 中 DiskNet 的性能基于物理信息初始化，它允许模型从良好的初始点开始学习最佳参数.我们评估了耦合罗斯勒动力学上的 DiskNet 版本：(1) 没有初始化超节点的双曲嵌入和/或 (2) 没有预训练赋值矩阵计算模块。结果（如表 3 所示）表明，虽然在许多情况下，未进行物理初始化的 DiskNet 与基线版本相比具有竞争力，但始终不如物理初始化版本，这证明了物理初始化的必要性。</p>
<h2 id="4-4-Sensitivity-Analysis"><a href="#4-4-Sensitivity-Analysis" class="headerlink" title="4.4 Sensitivity Analysis"></a>4.4 Sensitivity Analysis</h2><p>在本节中，我们将分析两个重要超参数（即缩减率 γ 和聚类计数 k）对 DiskNet 预测性能的影响。</p>
<p>4.4.1 Reduction ratio. 缩减率 γ 设定了骨架中超级节点数量的上限。虽然模型会根据拓扑和动力学特性自动确定分配关系，允许一些超级节点不分配给任何子节点，但超级节点的比例不会超过 γ。我们在 BA 网络和 PowerGrid 网络中进行了耦合罗斯勒动力学测试，如图 6 所示。我们将占用率定义为在所有可用超级节点中至少分配到一个子节点的超级节点比例。观察发现，当 γ 小于 1%时，预测性能最差，占用率最高。这表明超节点的上限太低，无法确定合适的骨架。当 γ 超过 25% 时，预测性能变得相似。这既表明了网络动力学的低维特性，也表明将 γ 设为 50%一般就足够了，因为模型能够自适应地确定适当的占用率。最后，尽管两个网络都由大约 5000 个节点组成，但在相同 γ 条件下，PowerGrid 网络的占用率略高于 BA 网络。这表明，PowerGrid 电网中的耦合罗斯勒动力学具有相对较高的维度，给预测带来了更大的挑战，这与表 1 中的预测误差相对应。</p>
<p>4.4.2 Cluster count k. 集群数 k 代表超分辨率模块中细化器的数量，与预测性能呈正相关。不过，它需要与模型的参数大小保持平衡。我们对社交网络和 Web 网络中的 FitzHugh-Nagumo 动力学进行了不同时间尺度（horizon）的预测测试，如图 7 所示。当 k 小于 7 时，k 越大，预测误差越小。但是，当 k 超过 7 时，进一步增加 k 并不能显著提高性能。因此，我们建议在一般情况下使用默认的 10 k 值，这样可以在性能和计算成本之间取得平衡。</p>
<h1 id="5-RELATED-WORK"><a href="#5-RELATED-WORK" class="headerlink" title="5 RELATED WORK"></a>5 RELATED WORK</h1><h2 id="5-1-Learning-Network-Dynamics"><a href="#5-1-Learning-Network-Dynamics" class="headerlink" title="5.1 Learning Network Dynamics"></a>5.1 Learning Network Dynamics</h2><p>现实世界中的许多系统都具有非线性和多尺度特性[23]，其动态常常被抽象为复杂的网络模型，从而说明节点之间的相互作用[5, 13, 25]。随着 GNN 等深度学习技术的发展，复杂网络动态的数据驱动建模受到了极大关注 [11]。Murphy 等人[31]提出了一种 GNN 架构，它能以最小的动力学假设精确模拟疾病在网络上的传播。NCDN [50] 结合了神经 ODE [8] 和 GNN，首次为复杂网络的连续时间动力学建模。Huang 等人[16, 17]分别通过引入边缘动力学 ODE 和环境编码器，成功地建立了动态拓扑和跨环境网络动力学模型。然而，尽管 [35, 38] 已经证明网络动力学是在一个非常低维的子空间中演化的，但现有的方法仍然是对整个拓扑结构的动力学演化进行建模，这就无法捕捉主导网络长期演化的低维结构。</p>
<h2 id="5-2-Dimension-Reduction-of-Complex-Network"><a href="#5-2-Dimension-Reduction-of-Complex-Network" class="headerlink" title="5.2 Dimension Reduction of Complex Network"></a>5.2 Dimension Reduction of Complex Network</h2><p>由于大规模网络的存储和计算成本较高，Serrano 等人[37]提出了差异过滤器，以确保在多尺度网络的剪枝过程中保留小尺度成分。García-Pérez等人[14]设计了基于角度相似性假设的双曲重整化群方法来识别复杂网络的低维骨架，Villegas等人[40]提出了一种基于拉普拉斯重整化群扩散的异构网络图像。Kumar 等人[22]以节点特征一致性为指导，通过端到端训练学习低维骨架。此外，一些关于图案学习的研究[18, 45]将原始图形中的每个图案视为超级节点，从而构建了一个聚集高阶几何特征的骨架。然而，这些方法只考虑了网络的静态特性，无法指导网络动态建模。Gao 等人[13]通过将原始系统映射到有效代表的一维系统来捕捉宏观动态，并进一步开发了基于度数的降维方法[29]，成功捕捉到了异构网络中相变的临界点。然而，这些基于专家知识的传统方法无法根据节点在不同拓扑结构和动力学条件下表现出的集体行为自动识别出最合适的骨架</p>
<h2 id="5-3-Hyperbolic-Graph-Learning"><a href="#5-3-Hyperbolic-Graph-Learning" class="headerlink" title="5.3 Hyperbolic Graph Learning"></a>5.3 Hyperbolic Graph Learning</h2><p>双曲几何的负曲率特性导致了非线性距离度量，使其能够更好地捕捉图结构数据中的层次关系和非线性依赖关系。Nickel 等人[32, 33]将符号数据嵌入 Poincaré 球和洛伦兹模型，捕捉非结构化数据的层次结构和相似性。Liu 等人[26]和 Chami 等人[7]通过黎曼流形映射将双曲几何引入图表示学习，显著提高了节点分类任务的性能。Yang 等人[46, 47]进一步利用双曲几何对时变网络的层次结构进行建模。虽然这些工作证明了双曲几何适合表示网络结构数据，但在复杂网络动态建模方面仍缺乏应用。</p>
<h1 id="6-CONCLUSIONS-AND-FUTURE-WORK"><a href="#6-CONCLUSIONS-AND-FUTURE-WORK" class="headerlink" title="6 CONCLUSIONS AND FUTURE WORK"></a>6 CONCLUSIONS AND FUTURE WORK</h1><p>本文通过一种基于双曲节点嵌入的骨架识别方法，探讨了复杂网络动力学的低维骨架及其在长期预测中的关键作用。通过在双曲空间中表示节点的集体动力学行为，我们计算了自适应赋值矩阵来识别骨架。然后，我们通过对超级节点的动态建模并将其提升到原始节点，从而实现有效的长期预测。广泛的实验结果表明，我们的模型在准确性和鲁棒性方面明显优于基线模型。此外，我们还验证了双曲几何在表示网络动态的低维结构方面优于欧几里得空间的能力。我们通过可视化结果，展示了同一拓扑结构上不同动态产生的不同骨架，从而证明了仅根据拓扑特征识别骨架的局限性。分析结果表明，在确保预测准确性的同时，不同类型的大规模网络的动态还具有丰富的降维潜力。未来，我们计划探索复杂网络的拓扑结构和动力学如何在确保预测准确性的同时影响可实现的最大降维。此外，我们还计划设计一种自动选择降维比率 γ 的机制。</p>
<h1 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h1><h2 id="RG-Renormalization-Group"><a href="#RG-Renormalization-Group" class="headerlink" title="RG(Renormalization Group)"></a>RG(Renormalization Group)</h2><p>通过缩放系统的不同部分，来简化系统的描述，并捕捉系统的整体行为。</p>
<ul>
<li><p>尺度变换：在复杂系统中，我们可以将系统中的变量（如位置、动量、温度等）进行不同尺度的“重标定”或“缩放”。这种操作可以去除系统中无关的细节，保留重要的全局行为特征。</p>
</li>
<li><p>保持不变的物理量：通过这种缩放操作，系统的某些特征，如相变点、临界指数等，可以在不同的尺度上保持不变。这个“保持不变”的特性被称为“自相似性”或“重标定不变性”。</p>
</li>
<li><p>在复杂网络中的应用：在网络科学中，Renormalization Group 方法可以用来分析复杂网络在不同尺度下的结构特征，特别是在寻找网络的“骨架”（skeleton）或核心结构时。例如，论文提到的“degree distribution”（度分布）和“clustering coefficient”（聚类系数）等网络特性，可以通过RG方法被提取和保留，在不同尺度下仍然具有相似的统计性质。</p>
</li>
</ul>
<h2 id="复杂网络中的双曲几何"><a href="#复杂网络中的双曲几何" class="headerlink" title="复杂网络中的双曲几何"></a>复杂网络中的双曲几何</h2><ul>
<li>复杂网络连接一些可区分的异质的元素，这里的异质表明所有的节点可以以某种方式进行分类。一般情况下，这些分类表明，节点在分为一大组后还可以继续分为一些小的组。这些组和子组之间可以近似看为树结构，表示网络潜在的分层结构。而我们可以将树看作离散的双曲空间，双曲空间看作连续的树结构，从纯度量意义下，两者是相同的。</li>
<li>复杂网络的度幂律分布和聚类现象是双曲几何负曲率和度量性质的简单反映(例如，幂律度分布的指数是双曲空间曲率的函数)；<img src="/2024/11/13/DiskNet/tree.png" class="" title="tree">
因此，如果假设节点属性首先具有某种度量结构，那么基于节点属性相似性的节点间距离可以映射到双曲空间中的距离。</li>
</ul>
]]></content>
      <categories>
        <category>Paper</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Graph</tag>
        <tag>Dynamics</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题02.07 intersection-of-two-linked-lists-lcci</title>
    <url>/2024/12/10/leetcode02-07/</url>
    <content><![CDATA[<h1 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p>
<blockquote>
<p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>输出：Intersected at ‘8’<br>解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。<br>在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。  </p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求出两个链表长度之差，将长链表前进gap个步，之后可以同时进行比较。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* cur_a = headA;</span><br><span class="line">        ListNode* cur_b = headB;</span><br><span class="line">        <span class="type">int</span> len_a = <span class="number">0</span>,len_b =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur_a != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            cur_a = cur_a-&gt;next;</span><br><span class="line">            len_a ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur_b != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            cur_b = cur_b-&gt;next;</span><br><span class="line">            len_b++;</span><br><span class="line">        &#125;</span><br><span class="line">        cur_a = headA;</span><br><span class="line">        cur_b = headB;</span><br><span class="line">        <span class="keyword">if</span>(len_b &gt; len_a)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(len_a,len_b);</span><br><span class="line">            <span class="built_in">swap</span>(cur_a,cur_b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> gap = len_a - len_b;</span><br><span class="line">        <span class="keyword">while</span>(gap--)&#123;</span><br><span class="line">            cur_a = cur_a-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur_a != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur_a == cur_b)&#123;</span><br><span class="line">                <span class="keyword">return</span> cur_a;</span><br><span class="line">            &#125;</span><br><span class="line">            cur_a = cur_a-&gt;next;</span><br><span class="line">            cur_b = cur_b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><!-- flag of hidden posts -->]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>1047. remove-all-adjacent-duplicates-in-string</title>
    <url>/2024/12/17/leetcode1047/</url>
    <content><![CDATA[<h1 id="删除字符串中的所有相邻重复项"><a href="#删除字符串中的所有相邻重复项" class="headerlink" title="删除字符串中的所有相邻重复项"></a>删除字符串中的所有相邻重复项</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给出由小写字母组成的字符串 s，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 s 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p>示例一</p>
<blockquote>
<p> 输入：”abbaca”<br>输出：”ca”<br>解释<br>例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。  </p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用栈，如果下一个字符和栈顶相同，那就需要弹出栈内元素，不相同就加入栈。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st.<span class="built_in">empty</span>() || s[i] != st.<span class="built_in">top</span>())&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res += st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><!-- flag of hidden posts -->]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>15. 3sum</title>
    <url>/2024/12/12/leetcode15/</url>
    <content><![CDATA[<h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：nums = [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]<br>解释：<br>nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。<br>nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。<br>nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。<br>不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。<br>注意，输出的顺序和三元组的顺序并不重要  </p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目的难点主要在于去重逻辑的思考。因为三元组不可以重复，但是三元组内部的元素可以重复。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 如果第一个元素已经大于0，不需要进一步检查</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 跳过相同的元素以避免重复</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">            left = i + <span class="number">1</span></span><br><span class="line">            right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> right &gt; left:</span><br><span class="line">                sum_ = nums[i] + nums[left] + nums[right]</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> sum_ &lt; <span class="number">0</span>:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> sum_ &gt; <span class="number">0</span>:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    result.append([nums[i], nums[left], nums[right]])</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># 跳过相同的元素以避免重复</span></span><br><span class="line">                    <span class="keyword">while</span> right &gt; left <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> right &gt; left <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                        </span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">programmercarl</a></p>
<!-- flag of hidden posts -->]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>kamacoder58. 区间和</title>
    <url>/2024/12/05/kamacoder58/</url>
    <content><![CDATA[<h1 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。<br><strong>输入描述</strong></p>
<ul>
<li>第一行输入为整数数组 Array 的长度 n，接下来 n 行，每行一个整数，表示数组的元素。随后的输入为需要计算总和的区间下标：a，b （b &gt; = a），直至文件结束。<br><strong>输出描述</strong></li>
<li>输出为每行一个整数，表示区间内元素的总和。</li>
</ul>
<p><strong>输入示例</strong></p>
<blockquote>
<p>5<br>1<br>2<br>3<br>4<br>5<br>0 1<br>1 3  </p>
</blockquote>
<p><strong>输出示例</strong></p>
<blockquote>
<p>3<br>9</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>前缀和<br>假设$S_i$为前$i$个元素的和，那么$S_j-S_i$就是第$i$个元素到第$j$个元素的和。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, a, b;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">int</span> presum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;vec[i]);</span><br><span class="line">        presum += vec[i];</span><br><span class="line">        p[i] = presum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b)) &#123;</span><br><span class="line">        <span class="type">int</span> sum;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>) sum = p[b];</span><br><span class="line">        <span class="keyword">else</span> sum = p[b] - p[a - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://programmercarl.com/kamacoder/0058.%E5%8C%BA%E9%97%B4%E5%92%8C.html#%E6%80%9D%E8%B7%AF">programmercarl</a></p>
<!-- flag of hidden posts -->]]></content>
      <categories>
        <category>kamacoder</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>151. reverse-words-in-a-string</title>
    <url>/2024/12/13/leetcode151/</url>
    <content><![CDATA[<h1 id="反转字符串中的单词"><a href="#反转字符串中的单词" class="headerlink" title="反转字符串中的单词"></a>反转字符串中的单词</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 s ，请你反转字符串中 单词 的顺序。</p>
<p>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。</p>
<p>返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。</p>
<p>注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：s = “the sky is blue”<br>输出：”blue is sky the”</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>总共分为三步：</p>
<ol>
<li>删除多余的空格</li>
<li>反转整个字符串</li>
<li>反转每一个word</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        s = s.strip()</span><br><span class="line">        s = s[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(word[::-<span class="number">1</span>] <span class="keyword">for</span> word <span class="keyword">in</span> s.split())</span><br></pre></td></tr></table></figure><!-- flag of hidden posts -->]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>203. remove-linked-list-elements</title>
    <url>/2024/12/06/leetcode203/</url>
    <content><![CDATA[<h1 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点</p>
<p>示例1：</p>
<blockquote>
<p><strong>输入：</strong> head = [1,2,6,3,4,5,6], val = 6<br><strong>输出：</strong>[1,2,3,4,5}  </p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用一个虚拟头节点判断，最后返回虚拟头节点-&gt;next</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>时间复杂度O(n)<br>空间复杂度O(1)<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* cur = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);<span class="comment">//虚拟头节点</span></span><br><span class="line">        cur-&gt;next = head;</span><br><span class="line">        ListNode* loop = cur;</span><br><span class="line">        <span class="keyword">while</span>(loop-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(loop-&gt;next-&gt;val == val)&#123;</span><br><span class="line">                ListNode* temp = loop-&gt;next;<span class="comment">//C++回收内存</span></span><br><span class="line">                loop-&gt;next = loop-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> temp;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                loop = loop-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = cur-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> cur;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>另外有一种递归的思维来解决本题<br>基础情况：对于空链表，不需要移除元素。<br>递归情况：首先检查头节点的值是否为 val，如果是则移除头节点，答案即为在头节点的后续节点上递归的结果；如果头节点的值不为 val，则答案为头节点与在头节点的后续节点上递归得到的新链表拼接的结果。</p>
</blockquote>
<p>时间复杂度O(n)<br>空间复杂度O(n)<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 基础情况：空链表</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归处理</span></span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val == val) &#123;</span><br><span class="line">            ListNode* newHead = <span class="built_in">removeElements</span>(head-&gt;next, val);</span><br><span class="line">            <span class="keyword">delete</span> head;</span><br><span class="line">            <span class="keyword">return</span> newHead;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head-&gt;next = <span class="built_in">removeElements</span>(head-&gt;next, val);</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<!-- flag of hidden posts -->]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>202. happy-number</title>
    <url>/2024/12/10/leetcode202/</url>
    <content><![CDATA[<h1 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个算法来判断一个数 n 是不是快乐数。 </p>
<p>「快乐数」 定义为：</p>
<ul>
<li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。 </li>
<li>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。 </li>
<li>如果这个过程 结果为 1，那么这个数就是快乐数。 </li>
<li><p>如果 n 是 快乐数 就返回 true ；不是，则返回 false 。 </p>
<p>示例1：</p>
<blockquote>
<p>输入：n = 19<br>输出：true<br>解释：<br>12 + 92 = 82<br>82 + 22 = 68<br>62 + 82 = 100<br>12 + 02 + 02 = 1  </p>
</blockquote>
</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>正常模拟，但是需要一个提前中断，如果sum在之前出现过 直接return false。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="type">int</span> temp = n%<span class="number">10</span>;</span><br><span class="line">            sum += temp*temp;</span><br><span class="line">            n = n/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; sum_set;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="built_in">getSum</span>(n);</span><br><span class="line">            <span class="keyword">if</span>(sum==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(sum_set.<span class="built_in">find</span>(sum) != sum_set.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum_set.<span class="built_in">insert</span>(sum);</span><br><span class="line">            &#125;</span><br><span class="line">            n = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><!-- flag of hidden posts -->]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>206. reverse-linked-list</title>
    <url>/2024/12/06/leetcode206/</url>
    <content><![CDATA[<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
<p><strong>示例1：</strong>  </p>
<blockquote>
<p><strong>输入：</strong> head = [1,2,3,4,5]<br><strong>输出：</strong>[5,4,3,2,1]</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>双指针<br>只需要改变当前链表节点的指向指向前一个节点即可。创建一个temp保存之前的下一个节点即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* temp;</span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            temp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- flag of hidden posts -->]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>209. minimum-size-subarray-sum</title>
    <url>/2024/11/27/leetcode209/</url>
    <content><![CDATA[<h1 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p>
<p>示例：</p>
<ul>
<li>输入：s = 7, nums = [2,3,1,2,4,3]</li>
<li>输出：2</li>
<li>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</li>
</ul>
<p>提示：</p>
<ul>
<li>1 &lt;= target &lt;= 10^9</li>
<li>1 &lt;= nums.length &lt;= 10^5</li>
<li>1 &lt;= nums[i] &lt;= 10^5</li>
</ul>
<p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li>暴力法，两个循环不断寻找子序列<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 时间复杂度O(n^2)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, s: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l = <span class="built_in">len</span>(nums)</span><br><span class="line">        min_len = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">            cur_sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, l):</span><br><span class="line">                cur_sum += nums[j]</span><br><span class="line">                <span class="keyword">if</span> cur_sum &gt;= s:</span><br><span class="line">                    min_len = <span class="built_in">min</span>(min_len, j - i + <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> min_len <span class="keyword">if</span> min_len != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
2.滑动窗口<br>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</li>
</ol>
<p>窗口的起始位置如何移动：如果当前窗口的值大于等于s了，窗口就要向前移动了（也就是该缩小了）。</p>
<p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">// 时间复杂度O(n)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        i,sum_wid,sublength = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            sum_wid += nums[j]</span><br><span class="line">            <span class="keyword">while</span>(sum_wid &gt;= target):</span><br><span class="line">                sublength = j-i+<span class="number">1</span></span><br><span class="line">                res = <span class="built_in">min</span>(res,sublength)</span><br><span class="line">                sum_wid -= nums[i]</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res!= <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> s, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = INT32_MAX; <span class="comment">// 最终的结果</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">// 子序列的数值之和</span></span><br><span class="line">        <span class="type">int</span> subLength = <span class="number">0</span>; <span class="comment">// 子序列的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 设置子序列起点为i</span></span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); j++) &#123; <span class="comment">// 设置子序列终止位置为j</span></span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt;= s) &#123; <span class="comment">// 一旦发现子序列和超过了s，更新result</span></span><br><span class="line">                    subLength = j - i + <span class="number">1</span>; <span class="comment">// 取子序列的长度</span></span><br><span class="line">                    result = result &lt; subLength ? result : subLength;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 因为我们是找符合条件最短的子序列，所以一旦符合条件就break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span></span><br><span class="line">        <span class="keyword">return</span> result == INT32_MAX ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><p><a href="https://programmercarl.com/">代码随想录</a></p>
<!-- flag of hidden posts -->]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>19. remove-nth-node-from-end-of-list</title>
    <url>/2024/12/09/leetcode19/</url>
    <content><![CDATA[<h1 id="删除链表倒数第n个节点"><a href="#删除链表倒数第n个节点" class="headerlink" title="删除链表倒数第n个节点"></a>删除链表倒数第n个节点</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<p>示例1：</p>
<blockquote>
<p><strong>输入：</strong>  head = [1,2,3,4,5], n = 2<br><strong>输出：</strong> [1,2,3,5]</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>让快指针先行n步，即保持快慢指针的距离是n，那么慢指针指向的节点就是要删除的节点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummynode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummynode-&gt;next = head;</span><br><span class="line">        ListNode* slow = dummynode;</span><br><span class="line">        ListNode* fast = dummynode;</span><br><span class="line">        <span class="keyword">while</span>(n--&amp;&amp; fast!= <span class="literal">NULL</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        head = dummynode-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<!-- flag of hidden posts -->]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>242. valid-anagram</title>
    <url>/2024/12/10/leetcode242/</url>
    <content><![CDATA[<h1 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的<br>字母异位词。</p>
<p>示例：</p>
<blockquote>
<p>输入: s = “anagram”, t = “nagaram”<br>输出: true</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用一个大小为26的数组来统计a-z字符出现的次数，统计s中出现的字符次数，再减去t中出现的次数，若数组全为0，那么true</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            count[s[i]-<span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            count[t[i]-<span class="string">&#x27;a&#x27;</span>] --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count[i]!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><!-- flag of hidden posts -->]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>26. remove-duplicates-from-sorted-array</title>
    <url>/2024/11/27/leetcode26/</url>
    <content><![CDATA[<h1 id="删除有序数组中的重复项"><a href="#删除有序数组中的重复项" class="headerlink" title="删除有序数组中的重复项"></a>删除有序数组中的重复项</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。</p>
<p>考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：</p>
<ul>
<li>更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。</li>
<li>返回 k 。</li>
</ul>
<p>示例 1：</p>
<ul>
<li>输入：nums = [1,1,2]</li>
<li>输出：2, nums = [1,2,_]</li>
<li>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</li>
</ul>
<p>示例 2：</p>
<ul>
<li>输入：nums = [0,0,1,1,1,2,2,3,3,4]</li>
<li>输出：5, nums = [0,1,2,3,4]</li>
<li>解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>快慢指针，慢指针指向新数组的下标，快指针进行判断，由于数组非严格递增，那么重复元素的下标一定是连续的。 如果发现不重复的元素就添加到新数组下标位置。此题注意边界情况<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        slow = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> fast <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != nums[fast-<span class="number">1</span>]:</span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br><span class="line">        </span><br></pre></td></tr></table></figure></p>
<!-- flag of hidden posts -->]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>24. swap-nodes-in-pairs</title>
    <url>/2024/12/06/leetcode24/</url>
    <content><![CDATA[<h1 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p><strong>示例一：</strong></p>
<blockquote>
<p>输入：head = [1,2,3,4]<br>输出：[2,1,4,3]</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>正常模拟即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummyhead-&gt;next = head;</span><br><span class="line">        ListNode* cur = dummyhead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode* temp0 = cur-&gt;next;</span><br><span class="line">            ListNode* temp1 = cur-&gt;next-&gt;next-&gt;next;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            cur-&gt;next-&gt;next = temp0;</span><br><span class="line">            cur-&gt;next-&gt;next-&gt;next = temp1;</span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* res = dummyhead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyhead;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- flag of hidden posts -->]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>283. move-zeroes</title>
    <url>/2024/11/27/leetcode283/</url>
    <content><![CDATA[<h1 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p>
<p><a href="https://leetcode.cn/problems/move-zeroes/">题目链接</a></p>
<p>示例 1:</p>
<ul>
<li>输入: nums = [0,1,0,3,12]</li>
<li>输出: [1,3,12,0,0]</li>
</ul>
<p>示例 2:</p>
<ul>
<li>输入: nums = [0]</li>
<li>输出: [0]</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>快慢指针，快指针获取不是0的值赋给慢指针指向的数组下标<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        slow = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> fast <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> fast != <span class="number">0</span>:</span><br><span class="line">                nums[slow] = fast</span><br><span class="line">                slow +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> slow &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            nums[slow] = <span class="number">0</span></span><br><span class="line">            slow +=<span class="number">1</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure></p>
<!-- flag of hidden posts -->]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>27. remove-element</title>
    <url>/2024/11/26/leetcode27/</url>
    <content><![CDATA[<h1 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p>
<p>你不需要考虑数组中超出新长度后面的元素</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。</p>
<h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>遍历数组，找到等于val的元素，将其后面的元素全部向前移动一位。此时时间复杂度为：$O(n^2)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == val) &#123; <span class="comment">// 发现需要移除的元素，就将数组集体向前移动一位</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; size; j++) &#123;</span><br><span class="line">                    nums[j - <span class="number">1</span>] = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                i--; <span class="comment">// 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位</span></span><br><span class="line">                size--; <span class="comment">// 此时数组的大小-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>双指针法（快慢指针法）</p>
<ul>
<li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li>
<li>慢指针：指向更新 新数组下标的位置</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fastIndex = <span class="number">0</span>; fastIndex &lt; nums.<span class="built_in">size</span>(); fastIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val != nums[fastIndex]) &#123;</span><br><span class="line">                nums[slowIndex++] = nums[fastIndex];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于vector的遍历元素，有更简洁的写法，在C++11中，提供了一种新的遍历方式：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> fast: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(val!= fast)&#123;</span><br><span class="line">                nums[slowIndex++] = fast;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="python-version"><a href="#python-version" class="headerlink" title="python version"></a>python version</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#快慢指针</span></span><br><span class="line"><span class="comment"># 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment"># 空间复杂度：O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        slow,fast = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> fast <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span>(fast != val):</span><br><span class="line">                nums[slow] = fast</span><br><span class="line">                slow +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 相向双指针法</span></span><br><span class="line"><span class="comment"># 时间复杂度 O(n)</span></span><br><span class="line"><span class="comment"># 空间复杂度 O(1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        left, right  = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> nums[left] != val:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> nums[right] == val:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; right:</span><br><span class="line">                nums[left] = nums[right]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><p><a href="https://programmercarl.com/">代码随想录</a></p>
<!-- flag of hidden posts -->]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>344. reverse-string</title>
    <url>/2024/12/12/leetcode344/</url>
    <content><![CDATA[<h1 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p>示例1：</p>
<blockquote>
<p>输入：s = [“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>双指针</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right):</span><br><span class="line">            s[left],s[right] = s[right],s[left]</span><br><span class="line">            left +=<span class="number">1</span></span><br><span class="line">            right -=<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><!-- flag of hidden posts -->]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>349. intersection-of-two-arrays</title>
    <url>/2024/12/10/leetcode349/</url>
    <content><![CDATA[<h1 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个数组 nums1 和 nums2 ，返回 它们的<br>交集。<br>输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。</p>
<p>示例1:</p>
<blockquote>
<p>输入：nums1 = [1,2,2,1], nums2 = [2,2]<br>输出：[2]</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>stl unordered_set来存储一个数组中出现的数字，再看另一个数组中的数字能否在这个set中找到，找到的set中的元素就是得到的数字。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(nums<span class="number">2.</span>begin(),nums<span class="number">2.</span>end())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums.<span class="built_in">find</span>(num) != nums.<span class="built_in">end</span>())&#123;</span><br><span class="line">                res.<span class="built_in">insert</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><!-- flag of hidden posts -->]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>454. 4sum-ii</title>
    <url>/2024/12/12/leetcode454/</url>
    <content><![CDATA[<h1 id="四数相加II"><a href="#四数相加II" class="headerlink" title="四数相加II"></a>四数相加II</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：  </p>
<ul>
<li>0 &lt;= i, j, k, l &lt; n</li>
<li>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</li>
</ul>
<p>示例1：</p>
<blockquote>
<p>输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]<br>输出：2<br>解释：<br>两个元组如下：  </p>
<ol>
<li>(0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0  </li>
<li>(1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0  </li>
</ol>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li>首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。</li>
<li>遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。</li>
<li>定义int变量count，用来统计 a+b+c+d = 0 出现的次数。</li>
<li>再遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。<br>5 .最后返回统计值 count 就可以了</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a:nums1)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> b:nums2)&#123;</span><br><span class="line">                mp[a+b]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> c:nums3)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> d:nums4)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mp.<span class="built_in">find</span>(<span class="number">0</span>-(c+d))!=mp.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    count += mp[<span class="number">0</span>-(c+d)];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://programmercarl.com/0454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II.html#%E6%80%9D%E8%B7%AF">programmercarl</a></p>
<!-- flag of hidden posts -->]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>35. search-insert-position</title>
    <url>/2024/11/27/leetcode35/</url>
    <content><![CDATA[<h1 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<p>示例 1:</p>
<ul>
<li>输入: [1,3,5,6], 5</li>
<li>输出: 2</li>
</ul>
<p>示例 2:</p>
<ul>
<li>输入: [1,3,5,6], 2</li>
<li>输出: 1</li>
</ul>
<p>示例 3:</p>
<ul>
<li>输入: [1,3,5,6], 7</li>
<li>输出: 4</li>
</ul>
<p>示例 4:</p>
<ul>
<li>输入: [1,3,5,6], 0</li>
<li>输出: 0<br><a href="https://leetcode.cn/problems/search-insert-position/">题目链接</a></li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li>暴力<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 时间复杂度O(n)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchInsert</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt;= target:</span><br><span class="line">                res = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
2.二分 适用于有序数组且不重复<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> middle = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &gt; target)&#123;</span><br><span class="line">                right = middle <span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt; target)&#123;</span><br><span class="line">                left = middle<span class="number">+1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right <span class="number">+1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><a href="https://programmercarl.com/">代码随想录</a></li>
</ol>
<!-- flag of hidden posts -->]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>367. valid-perfect-square</title>
    <url>/2024/11/27/leetcode367/</url>
    <content><![CDATA[<h1 id="有效的完全平方数"><a href="#有效的完全平方数" class="headerlink" title="有效的完全平方数"></a>有效的完全平方数</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个正整数 num 。如果 num 是一个完全平方数，则返回 true ，否则返回 false 。</p>
<p>完全平方数 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。</p>
<p>不能使用任何内置的库函数，如  sqrt 。</p>
<p><a href="https://leetcode.cn/problems/valid-perfect-square/">题目链接</a></p>
<p>示例 1：</p>
<ul>
<li>输入：num = 16</li>
<li>输出：true</li>
<li>解释：返回 true ，因为 4 * 4 = 16 且 4 是一个整数。</li>
</ul>
<p>示例 2：</p>
<ul>
<li>输入：num = 14</li>
<li>输出：false</li>
<li>解释：返回 false ，因为 3.742 * 3.742 = 14 但 3.742 不是一个整数。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>简单的二分查找</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = num;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((<span class="type">long</span>)mid * mid &gt; num)&#123;</span><br><span class="line">                r = mid <span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>((<span class="type">long</span>)mid * mid &lt;num)&#123;</span><br><span class="line">                l = mid <span class="number">+1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<!-- flag of hidden posts -->]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>704. Binary Search</title>
    <url>/2024/11/26/leetcode704/</url>
    <content><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。<br><a href="https://leetcode.cn/problems/binary-search/">题目链接</a><br><span id="more"></span></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二分查找的适用场景考虑，主要是需要数组有序，且数组内没有重复元素。二分法的主要错误在于循环时不变量的寻找，在二分法中，区间的定义就是循环的不变量。<br>考虑区间是左闭右开还是左闭右闭。<br><strong>示例1:</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9     </span><br><span class="line">输出: 4       </span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4    </span><br></pre></td></tr></table></figure><br><strong>示例2</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure></p>
<h2 id="第一种写法"><a href="#第一种写法" class="headerlink" title="第一种写法"></a>第一种写法</h2><p>在左闭右闭的区间上进行查找，循环不变量为[left, right]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 定义target在左闭右闭的区间里，[left, right]</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// 当left==right，区间[left, right]依然有效，所以用 &lt;=</span></span><br><span class="line">            <span class="type">int</span> middle = left + ((right - left) / <span class="number">2</span>);<span class="comment">// 防止溢出 等同于(left + right)/2</span></span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle - <span class="number">1</span>; <span class="comment">// target 在左区间，所以[left, middle - 1]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>; <span class="comment">// target 在右区间，所以[middle + 1, right]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// nums[middle] == target</span></span><br><span class="line">                <span class="keyword">return</span> middle; <span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(log n)<br>空间复杂度：O(1)</p>
<h2 id="第二种写法"><a href="#第二种写法" class="headerlink" title="第二种写法"></a>第二种写法</h2><p>在左闭右开的区间上进行查找，循环不变量为[left, right)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>(); <span class="comment">// 定义target在左闭右开的区间里，即：[left, right)</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span></span><br><span class="line">            <span class="type">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle; <span class="comment">// target 在左区间，在[left, middle)中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>; <span class="comment">// target 在右区间，在[middle + 1, right)中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// nums[middle] == target</span></span><br><span class="line">                <span class="keyword">return</span> middle; <span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><p><a href="https://programmercarl.com/">代码随想录</a></p>
<!-- flag of hidden posts -->]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>76： minimum-window-substring</title>
    <url>/2024/12/04/leetcode76/</url>
    <content><![CDATA[<h1 id="最小覆盖字串"><a href="#最小覆盖字串" class="headerlink" title="最小覆盖字串"></a>最小覆盖字串</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。<br><strong>示例 1：</strong></p>
<ul>
<li>输入：s = “ADOBECODEBANC”, t = “ABC”</li>
<li>输出：”BANC”</li>
<li>解释：最小覆盖子串 “BANC” 包含来自字符串 t 的 ‘A’、’B’ 和 ‘C’。</li>
</ul>
<p><strong>示例 2：</strong></p>
<ul>
<li>输入：s = “a”, t = “a”</li>
<li>输出：”a”</li>
<li>解释：整个字符串 s 是最小覆盖子串。</li>
</ul>
<p><strong>示例 3:</strong></p>
<ul>
<li>输入: s = “a”, t = “aa”</li>
<li>输出: “”</li>
<li><p>解释: t 中两个字符 ‘a’ 均应包含在 s 的子串中，<br>因此没有符合条件的子字符串，返回空字符串。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>滑动窗口</p>
<p>判断窗口内是否含有目标字符，此处使用哈希表存储。<br>再慢慢往右移动右边界，判断，记录最小窗口</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// hash map</span></span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;target,cnt;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; pair:target)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[pair.first]&lt;pair.second)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构建目标哈希表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; c:t)&#123;</span><br><span class="line">            target[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sublen = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>,end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;r&lt;s.<span class="built_in">size</span>();r++)&#123;</span><br><span class="line">            cnt[s[r]]++;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">check</span>())&#123;</span><br><span class="line">                <span class="keyword">if</span>(sublen==<span class="number">-1</span>||r-l<span class="number">+1</span>&lt;sublen)&#123;</span><br><span class="line">                    sublen = r-l<span class="number">+1</span>;</span><br><span class="line">                    start = l;</span><br><span class="line">                    end = r;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt[s[l]]--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sublen==<span class="number">-1</span>?<span class="string">&quot;&quot;</span>:s.<span class="built_in">substr</span>(start,end-start<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>可以优化，不记录第一个目标字符之前的字符。</p>
</li>
</ul>
<!-- flag of hidden posts -->]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>977. squares-of-a-sorted-array</title>
    <url>/2024/11/27/leetcode977/</url>
    <content><![CDATA[<h1 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p>
<p>示例 1：</p>
<ul>
<li>输入：nums = [-4,-1,0,3,10]</li>
<li>输出：[0,1,9,16,100]</li>
<li>解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</li>
</ul>
<p> 示例 2：</p>
<ul>
<li>输入：nums = [-7,-3,2,3,11]</li>
<li>输出：[4,9,9,49,121]</li>
</ul>
<p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">题目链接</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li>暴力，平方再sort</li>
<li>对向指针数组的最值出现在两侧，创建一个新数组存储<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 暴力</span></span><br><span class="line"><span class="comment"># python version</span></span><br><span class="line"><span class="comment"># 时间复杂度O(n+logn)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedSquares</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sorted</span>(x*x <span class="keyword">for</span> x <span class="keyword">in</span> nums)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对向指针</span></span><br><span class="line"><span class="comment">// 时间复杂度O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度O(n)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> k = nums.<span class="built_in">size</span>() <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>,j = k;i&lt;=j;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] *nums[i] &lt; nums[j]*nums[j])&#123;</span><br><span class="line">                res[k--] = nums[j]*nums[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[k--] = nums[i] *nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><p><a href="https://programmercarl.com/">代码随想录</a></p>
<!-- flag of hidden posts -->]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>59. spiral-matrix-ii/description</title>
    <url>/2024/12/04/leetcode59/</url>
    <content><![CDATA[<h1 id="螺旋矩阵-II"><a href="#螺旋矩阵-II" class="headerlink" title="螺旋矩阵 II"></a>螺旋矩阵 II</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</p>
<ul>
<li>输入：n = 3</li>
<li>输出：[[1,2,3],[8,9,4],[7,6,5]]</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>)); <span class="comment">// 使用vector定义一个二维数组</span></span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>; <span class="comment">// 定义每循环一个圈的起始位置</span></span><br><span class="line">        <span class="type">int</span> loop = n / <span class="number">2</span>; <span class="comment">// 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理</span></span><br><span class="line">        <span class="type">int</span> mid = n / <span class="number">2</span>; <span class="comment">// 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>; <span class="comment">// 用来给矩阵中每一个空格赋值</span></span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>; <span class="comment">// 需要控制每一条边遍历的长度，每次循环右边界收缩一位</span></span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">while</span> (loop --) &#123;</span><br><span class="line">            i = startx;</span><br><span class="line">            j = starty;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下面开始的四个for就是模拟转了一圈</span></span><br><span class="line">            <span class="comment">// 模拟填充上行从左到右(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (j; j &lt; n - offset; j++) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充右列从上到下(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (i; i &lt; n - offset; i++) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充下行从右到左(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt; starty; j--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充左列从下到上(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (; i &gt; startx; i--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)</span></span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// offset 控制每一圈里每一条边遍历的长度</span></span><br><span class="line">            offset += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span>) &#123;</span><br><span class="line">            res[mid][mid] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p><a href="https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
<!-- flag of hidden posts -->]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>螺旋数组</tag>
      </tags>
  </entry>
  <entry>
    <title>rjina-一个markdown网页的工具</title>
    <url>/2025/07/09/rjina/</url>
    <content><![CDATA[<h1 id="简单用法"><a href="#简单用法" class="headerlink" title="简单用法"></a>简单用法</h1><p><a href="https://r.jina.ai/">https://r.jina.ai/</a>+URL就可以将网页内容Markdown下来。</p>
<p>这里我以我自己博客内容为例。</p>
<p><a href="https://b1ue-e.github.io/2024/11/19/NSGA-II/#more">多目标遗传算法</a></p>
<p>只需要将网页的URL加在后面即可，如：<a href="">https://r.jina.ai/https://b1ue-e.github.io/2024/11/19/NSGA-II/#more</a></p>
<p>效果如图</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Title: 多目标遗传算法NSGA-II实现</span><br><span class="line"></span><br><span class="line">URL Source: https://b1ue-e.github.io/2024/11/19/NSGA-II/</span><br><span class="line"></span><br><span class="line">Published Time: 2024-11-19T02:30:54.000Z</span><br><span class="line"></span><br><span class="line">Markdown Content:</span><br><span class="line"><span class="section">[](<span class="link">https://b1ue-e.github.io/2024/11/19/NSGA-II/#INTRODUCTION &quot;INTRODUCTION&quot;</span>)INTRODUCTION</span></span><br><span class="line"><span class="section">----------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">非支配排序遗传算法（NSGA-II）是一种多目标优化算法，它通过在遗传算法的基础上引入非支配排序和拥挤度计算，以平衡多目标优化问题中的多个目标。NSGA-II是遗传算法的一种改进版本，它在遗传算法的基础上引入了<span class="strong">**非支配排序和拥挤度**</span>计算，以平衡多目标优化问题中的多个目标。本文将简要介绍NSGA-II的关键点和实现。</span><br><span class="line"></span><br><span class="line"><span class="section">[](<span class="link">https://b1ue-e.github.io/2024/11/19/NSGA-II/#%E9%9D%9E%E6%94%AF%E9%85%8D%E6%8E%92%E5%BA%8F &quot;非支配排序&quot;</span>)非支配排序</span></span><br><span class="line"><span class="section">-----------------------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="section">### [](<span class="link">https://b1ue-e.github.io/2024/11/19/NSGA-II/#%E6%94%AF%E9%85%8D%E5%92%8C%E9%9D%9E%E6%94%AF%E9%85%8D%E5%85%B3%E7%B3%BB &quot;支配和非支配关系&quot;</span>)支配和非支配关系</span></span><br><span class="line"></span><br><span class="line">设p和q是两个解，称p支配q，当且仅当，1. 对于所有的子目标，p的目标值都不劣于q的目标值；2. 至少有一个子目标，p的目标值优于q的目标值。</span><br><span class="line"></span><br><span class="line"><span class="section">### [](<span class="link">https://b1ue-e.github.io/2024/11/19/NSGA-II/#%E9%9D%9E%E6%94%AF%E9%85%8D%E6%8E%92%E5%BA%8F-1 &quot;非支配排序&quot;</span>)非支配排序</span></span><br><span class="line"></span><br><span class="line"><span class="emphasis">_Non-dominated Sorting_</span> 是一种用于多目标优化的排序算法，它将解按照支配关系划分为多个非支配集合。</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span>   初始化：将所有解放入一个初始非支配集合中。</span><br><span class="line"><span class="bullet">2.</span>   对每个解计算两个属性：（1）:解 被其他解支配的次数；（2）:解 支配的解的集合。</span><br><span class="line"><span class="bullet">3.</span>   然后找到 的解，将其放入一个新的集合 中，此时 的等级为1</span><br><span class="line"><span class="bullet">4.</span>   对 中的每个解 ，将其从 中删除，然后对 中的每个解 ，计算 ，如果 ，则将其放入 中，此时 的等级为2。依此类推，直至所有解被分类。</span><br><span class="line"><span class="section">### [](<span class="link">https://b1ue-e.github.io/2024/11/19/NSGA-II/#%E5%AE%9E%E7%8E%B0 &quot;实现&quot;</span>)实现</span></span><br></pre></td></tr></table></figure>
<h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><p><a href="https://linux.do/t/topic/774655">liangdabiao的帖子</a></p>
]]></content>
      <tags>
        <tag>-- toy</tag>
      </tags>
  </entry>
  <entry>
    <title>Polygenic enrichment distinguishes disease associations of individual cells in single-cell RNA-seq data</title>
    <url>/2024/11/15/scDRS/</url>
    <content><![CDATA[<h1 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h1><p>通过单细胞 RNA 测序（scRNA-seq）量化的单细胞级分辨率的基因表达，可以为疾病和复杂性状的病理和细胞起源提供独特的见解。在这里，我们介绍了单细胞疾病相关性评分（scDRS），这是一种在单细胞分辨率上将 scRNA-seq 与多基因疾病风险联系起来的方法；scDRS 可识别在由 GWAS 数据构建的疾病特异性基因集中基因表达水平过高的单个细胞。我们通过模拟确定，scDRS 在识别与疾病相关的单个细胞方面具有良好的校准性和强大的功能。我们将 scDRS 与 16 个 scRNA-seq 数据集（涵盖 31 个组织和器官的 130 万个细胞）结合起来，应用于 74 种疾病和复杂性状的 GWAS 数据（平均 N =341K）。在细胞类型层面，scDRS 广泛再现了经典细胞类型与疾病之间的已知联系，并产生了新的生物学上合理的发现。在单个细胞层面，scDRS 发现了现有细胞类型标签无法捕捉的疾病相关细胞亚群，包括与炎症性肠病相关的 CD4+ T 细胞亚群，其部分特征为效应样状态；与精神分裂症相关的海马 CA1 锥体神经元亚群，部分特征是它们的空间位置位于海马 CA1 区的近端；以及与甘油三酯水平相关的肝细胞亚群，部分特征是它们的倍性水平较高。在基因水平上，我们发现在单个细胞中表达与 scDRS 评分相关的基因（从而反映了与 GWAS 疾病基因的共同表达）强烈富集了黄金标准药物靶基因和孟德尔疾病基因。<br><span id="more"></span></p>
<img src="/2024/11/15/scDRS/method.png" class="" title="method">
<h1 id="METHOD"><a href="#METHOD" class="headerlink" title="METHOD"></a>METHOD</h1><p>scDRS 将 scRNA-seq 中的基因表达谱与 GWAS 中的多基因疾病信息整合在一起，通过评估特定细胞中 GWAS 推定疾病基因相对于所有细胞中具有相似表达的其他基因的过量表达，将单个细胞与疾病联系起来。</p>
<p><strong>首先</strong>，scDRS 利用现有的基因评分方法 MAGMA（前 1000 个 MAGMA 基因），从 GWAS 的汇总统计数据中构建一组推定疾病基因。</p>
<p><strong>其次</strong>，scDRS 对每个细胞中假定疾病基因的总表达量进行量化，以生成细胞特异性原始疾病评分；为了最大限度地提高权重，每个假定疾病基因都按其 GWAS MAGMA z-score 加权，并按其在单细胞数据中的基因特异性技术噪声水平反向加权，该噪声水平是通过对各基因的均值-方差关系建模估算得出的。为了确定统计显著性，scDRS 还根据匹配对照基因集的蒙特卡洛（Monte Carlo，MC）样本（与推定疾病基因的基因集大小、平均表达量和表达方差相匹配）生成 1000 组细胞特异性原始对照分数。</p>
<p><strong>第三</strong>，scDRS 对每个细胞的原始疾病得分和原始对照得分进行归一化处理（得出归一化疾病得分和归一化对照得分），然后根据所有对照基因组和所有细胞的集合归一化对照得分的经验分布计算细胞级 p 值。</p>
]]></content>
      <categories>
        <category>single-cell</category>
        <category>GWAS</category>
      </categories>
      <tags>
        <tag>single-cell</tag>
        <tag>disease relevance score</tag>
      </tags>
  </entry>
  <entry>
    <title>707. design-linked-list</title>
    <url>/2024/12/06/leetcode707/</url>
    <content><![CDATA[<h1 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>你可以选择使用单链表或者双链表，设计并实现自己的链表。</p>
<p>单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针/引用。</p>
<p>如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。</p>
<p>实现 MyLinkedList 类：</p>
<ul>
<li>MyLinkedList() 初始化 MyLinkedList 对象。</li>
<li>int get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。</li>
<li>void addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。</li>
<li>void addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。</li>
<li>void addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。</li>
<li>void deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>单链表实现<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode* next;</span><br><span class="line">        <span class="built_in">ListNode</span>(<span class="type">int</span> val):<span class="built_in">val</span>(val),<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        _dummyhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; (_size <span class="number">-1</span>) || index &lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* cur = _dummyhead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* temp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        temp-&gt;next = _dummyhead-&gt;next;</span><br><span class="line">        _dummyhead-&gt;next = temp;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* cur = _dummyhead;</span><br><span class="line">        ListNode* temp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = temp;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;_size) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span>)index=<span class="number">0</span>;</span><br><span class="line">        ListNode* new_node =<span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        ListNode* cur = _dummyhead;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        new_node-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = new_node;</span><br><span class="line">        _size ++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;_size <span class="number">-1</span> || index&lt;<span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">        ListNode* cur = _dummyhead;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* temp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        temp = <span class="literal">NULL</span>;</span><br><span class="line">        _size--;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">    ListNode* _dummyhead;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<!-- flag of hidden posts -->]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>904. fruit-into-baskets</title>
    <url>/2024/11/27/leetcode904/</url>
    <content><![CDATA[<h1 id="水果成篮"><a href="#水果成篮" class="headerlink" title="水果成篮"></a>水果成篮</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。</p>
<p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p>
<ul>
<li>你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。</li>
<li>你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</li>
<li>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</li>
</ul>
<p>给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。<br><a href="https://leetcode.cn/problems/fruit-into-baskets/">题目链接</a></p>
<p>示例 1：</p>
<ul>
<li>输入：fruits = [1,2,1]</li>
<li>输出：3</li>
<li>解释：可以采摘全部 3 棵树。</li>
</ul>
<p>示例 2：</p>
<ul>
<li>输入：fruits = [0,1,2,2]</li>
<li>输出：3</li>
<li>解释：可以采摘 [1,2,2] 这三棵树。</li>
<li>如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。</li>
</ul>
<p>示例 3：</p>
<ul>
<li>输入：fruits = [1,2,3,2,2]</li>
<li>输出：4</li>
<li>解释：可以采摘 [2,3,2,2] 这四棵树。</li>
<li>如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>滑动窗口，最大化窗口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for 窗口扩大</span><br><span class="line">		while(不满足条件)</span><br><span class="line">		 调整边界，使得条件满足</span><br><span class="line">		计算窗口大小</span><br><span class="line">		loop</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">totalFruit</span>(<span class="params">self, fruits: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">       ans = <span class="number">0</span></span><br><span class="line">       kinds = <span class="number">0</span></span><br><span class="line">       left = <span class="number">0</span></span><br><span class="line">       f = [<span class="number">0</span>]*(<span class="built_in">max</span>(fruits)+<span class="number">1</span>)</span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(fruits)):</span><br><span class="line">           <span class="keyword">if</span> f[fruits[i]] ==<span class="number">0</span>:</span><br><span class="line">               kinds +=<span class="number">1</span></span><br><span class="line">           f[fruits[i]] +=<span class="number">1</span></span><br><span class="line">           <span class="keyword">while</span>(kinds &gt;<span class="number">2</span>):</span><br><span class="line">               f[fruits[left]] -=<span class="number">1</span></span><br><span class="line">               <span class="keyword">if</span>(f[fruits[left]] == <span class="number">0</span>):</span><br><span class="line">                   kinds -= <span class="number">1</span></span><br><span class="line">               left += <span class="number">1</span></span><br><span class="line">           ans = <span class="built_in">max</span>(ans,i-left+<span class="number">1</span>)</span><br><span class="line">       <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       </span><br></pre></td></tr></table></figure>
<!-- flag of hidden posts -->]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
</search>
